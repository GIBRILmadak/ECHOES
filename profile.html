<!DOCTYPE html>
<html lang="fr" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHOES - Profil</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" href="icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icon.png">
    <link rel="shortcut icon" href="icon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
    <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <script defer src="supabase-config.js"></script>
    <script defer src="supabase-client.js"></script>
    <script defer src="auth-guard.js"></script>
    <script defer src="auth.js"></script>
    <script defer src="points.js"></script>
    <script defer src="badge-injector.js"></script>
    <style>
        .glass-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.36);
        }
        .glass-card-light {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }
        /* Nouveaux styles pour lisibilité des statistiques / badges / média */
        .profile-header { /* ajuste l'espace entre nom et stats */
            margin-top: -6rem !important; /* restaure un chevauchement net de la bannière */
            margin-bottom: 0.30rem; /* réduit l'écart visuel */
        }

        @media (max-width: 640px) {
            .profile-header {
                margin-top: 0 !important; /* aucun chevauchement sur mobile */
            }
        }
        .stat-number {
            font-weight: 800; /* chiffre plus épais */
            font-size: 1.125rem;
        }
        .stat-label {
            font-weight: 400; /* label plus fin */
            font-size: 0.75rem;
        }
        .stat-item i { /* petite icône à côté du chiffre */
            vertical-align: middle;
            margin-right: 0.35rem;
        }
        .badge-label {
            font-size: 0.7rem;
            margin-top: 0.35rem;
            color: rgba(255,255,255,0.8);
        }
        .badge.rare > div:first-child { /* neutralisé: pas de mise en avant */
            box-shadow: none;
            transform: none;
        }
        /* Neutraliser les fonds colorés des badges (gradients, couleurs) */
        .badge > div:first-child {
            background: transparent !important;
        }
        .post-media {
            object-fit: cover;
            max-height: 15rem; /* taille uniforme */
            width: 100%;
        }
        /* Onglets : espacement réduit et transition douce pour l'état actif */
        .tabs { margin-bottom: 0.75rem; }
        .tab-btn { transition: all 160ms ease; }
        .tab-btn[aria-pressed="true"] {
            box-shadow: 0 6px 18px rgba(59,130,246,0.12);
            transform: translateY(-2px);
        }

        /* === Ajout : gestion centralisée de la couleur du texte pour thème sombre/clair ===
           On utilise des variables CSS et un override global pour garantir que
           le texte passe en blanc en sombre et en noir en clair sans modifier le JS.
        */
        :root {
            --main-text: #000000;            /* texte par défaut (thème clair) */
            --muted-text: rgba(0,0,0,0.55);  /* texte atténué par défaut */
        }
        html.dark {
            --main-text: #ffffff;            /* texte en thème sombre */
            --muted-text: rgba(255,255,255,0.78);
        }

        /* Forcer la couleur de texte principale via body pour surclasser les utilitaires Tailwind */
        body {
            color: var(--main-text) !important;
        }
        /* Utilitaires courants qui affichent du texte atténué/probablement en .opacity-75 */
        .opacity-75 {
            color: var(--muted-text) !important;
        }
        /* Assurer que les classes text-white/text-black suivent la variable principale */
        .text-white, .text-black {
            color: var(--main-text) !important;
        }
        /* Si des SVG/icônes utilisent currentColor, elles suivront automatiquement la variable */
        svg {
            color: inherit;
        }

        /* === Nouveaux styles pour mise en valeur du bloc profil/bannière === */
        .profile-banner {
            /* hauteur augmentée pour plus d'impact */
            height: 12rem; /* équiv. h-48 */
            background-size: cover;
            background-position: center;
            position: relative;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        }
        /* Ajustements du bloc photo/nom/pseudo */
        .profile-block { /* regroupe photo/nom/pseudo et ajoute séparation nette des stats */
            padding-top: 0.75rem; /* léger espace sous la bannière, laisse l'avatar empiéter */
            padding-bottom: 1rem;
        }
        .profile-avatar {
            width: 7rem; /* w-28 */
            height: 7rem;
            object-fit: cover;
            border-radius: 50%; /* Ensure perfect circle */
            flex-shrink: 0; /* Prevent shrinking */
            margin-top: -0.75rem; /* encastrement par défaut (légèrement plus haut) */
        }
        /* Increase overlap on small screens */
        @media (max-width: 639px) {
            .profile-avatar { margin-top: -2.25rem !important; }
        }
        /* Slight overlap of avatar into the banner on larger screens */
        @media (min-width: 640px) {
            .profile-avatar {
                margin-top: -1.75rem !important; /* encastrement légèrement plus haut sur ≥640px */
                position: relative;
                z-index: 2; /* s'assure que l'avatar passe au-dessus du bord de la bannière */
            }
        }
        .profile-name {
            font-size: 1.5rem; /* text-3xl environ */
            font-weight: 800;
            line-height: 1.05;
        }
        .profile-handle {
            font-size: 0.9rem;             /* légèrement plus petit */
            font-weight: 500;              /* moins gras */
            color: #B0B0B0 !important;     /* teinte gris doux demandée */
            text-shadow: none;             /* conserve un rendu net pour la nouvelle couleur */
            background: rgba(255,255,255,0.02); /* petit fond pour détacher du background */
            padding: 0.08rem 0.28rem;
            border-radius: 0.25rem;
            margin-top: 0.1rem;            /* réduit l'écart sous le nom */
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            vertical-align: baseline;      /* align with text baseline */
            line-height: 1.2;              /* consistent line height */
        }
        .thought-display-style {
            font-style: italic;
            color: var(--muted-text);
            text-align: center;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background: rgba(0,0,0,0.1);
            border-radius: 0.75rem;
        }
        /* style du bouton de modification du pseudo */
        .edit-handle-btn {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            padding: 0.18rem 0.45rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            color: var(--main-text);
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            vertical-align: baseline;      /* align with text baseline */
            line-height: 1.2;              /* consistent line height */
        }

        /* Espace clair entre le groupe profil et les stats */
        .profile-separator {
            margin-top: 0.75rem;
            border-top: 1px solid rgba(255,255,255,0.04);
            padding-top: 0.75rem;
        }

        /* Ensure a pleasant max width on large desktop screens without breaking Tailwind setup */
        /* Conteneur principal : largeur par défaut un peu réduite */
        .content-max {
            max-width: 1000px; /* largeur par défaut (affecte grand écrans) */
            margin-left: auto;
            margin-right: auto;
            padding-left: 1rem;
            padding-right: 1rem;
        }

        /* Pour écrans de bureau larges, resserrer encore la largeur pour meilleure lisibilité */
        @media (min-width: 1024px) {
            .content-max {
                max-width: 900px; /* largeur cible pour écrans de bureau */
            }
        }

        /* === Navigation flottante sans animation === */
        .floating-nav {
            z-index: 9999; /* toujours au-dessus du contenu */
            transition: none;
            will-change: auto;
            pointer-events: auto; /* s'assurer qu'il reçoit les interactions */
        }
        .floating-nav:hover,
        .floating-nav:focus-within {
            transform: translateX(-50%); /* aucun lift au survol */
            box-shadow: none;
        }
        @media (prefers-reduced-motion: reduce) {
            .floating-nav {
                transition: none;
            }
            .floating-nav:hover,
            .floating-nav:focus-within {
                transform: translateX(-50%);
                box-shadow: none;
            }
        }

        /* === Background selector: horizontal thumbnail rail per theme === */
        /* Show the selector inline as a horizontal scroller and keep thumbnail sizes consistent */
        #background-selector,
        #settings-theme-bg-row,
        #backgrounds-section-row {
            display: block;
            width: 100%;
            overflow-x: auto; /* horizontal scrolling for many thumbnails */
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            padding-bottom: 0.5rem; /* small gutter for scrollbar */
            /* Allow right-to-left scrolling so users can scroll de droite à gauche */
            direction: rtl;
        }
        /* Force the JS-created theme rows to be horizontal rails */
        #background-selector .flex,
        #settings-theme-bg-row,
        #backgrounds-section-row {
            display: flex !important;
            align-items: center;
            gap: 0.5rem; /* consistent spacing between thumbnails */
            padding: 0.25rem 0;
        }
        /* Uniform, larger clickable targets for thumbnails (applies to both inline selector and settings drawer) */
        #background-selector button,
        #settings-theme-bg-row button,
        #backgrounds-section-row button {
            width: 96px !important;
            height: 56px !important;
            min-width: 96px !important;
            border-radius: 0.5rem;
            background-size: cover !important;
            background-position: center center !important;
            flex: 0 0 auto; /* prevent shrinking in the rail */
            border: 2px solid transparent;
            background-repeat: no-repeat !important;
        }
        /* Keep the visual layout of the thumbnail content left-to-right even when the rail is RTL */
        #settings-theme-bg-row button,
        #backgrounds-section-row button { direction: ltr; }
        /* Hide the opposite theme group via JS remains intact; no change needed here */
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-900 to-black text-white dark:text-dark-text dark:bg-gradient-to-br dark:from-blue-900 dark:to-black">
    <div id="vanta-bg" class="fixed inset-0 -z-10 bg-cover bg-center"></div>
    <!-- Navigation -->
    <nav class="glass-card floating-nav fixed bottom-4 left-1/2 transform -translate-x-1/2 rounded-full px-4 sm:px-6 py-3 sm:py-3 flex items-center justify-center space-x-3 sm:space-x-8 z-50" role="navigation" aria-label="Navigation principale">
        <a href="index.html" class="p-1 sm:p-2 rounded-full hover:bg-dark-secondary dark:hover:bg-opacity-30">
            <i data-feather="home" class="w-4 h-4 sm:w-5 sm:h-5"></i>
        </a>
        <a href="videos.html" class="p-1 sm:p-2 rounded-full hover:bg-dark-secondary dark:hover:bg-opacity-30">
            <i data-feather="video" class="w-4 h-4 sm:w-5 sm:h-5"></i>
        </a>
                <a href="forum.html" class="p-1 sm:p-2 rounded-full hover:bg-dark-secondary dark:hover:bg-opacity-30">
            <i data-feather="message-square" class="w-4 h-4 sm:w-5 sm:h-5"></i>
        </a>
        <a href="messages.html" class="p-1 sm:p-2 rounded-full hover:bg-dark-secondary dark:hover:bg-opacity-30">
            <i data-feather="mail" class="w-4 h-4 sm:w-5 sm:h-5"></i>
        </a>
        <a href="calm.html" class="p-1 sm:p-2 rounded-full hover:bg-dark-secondary dark:hover:bg-opacity-30">
            <i data-feather="book" class="w-4 h-4 sm:w-5 sm:h-5"></i>
        </a>
        
    </nav>

    <!-- Main Content -->
    <div class="container mx-auto px-4 pt-8 pb-24 content-max">
        <!-- Profile Header -->
        <div class="glass-card rounded-2xl overflow-hidden mb-6">
            <!-- Banner -->
            <div id="profile-banner" class="profile-banner relative" data-placeholder="images/banner.jpg" style="background-image: url('images/banner.jpg'); background-size: cover; background-position: center;">
                <button id="banner-edit-btn" class="absolute top-3 right-3 bg-black bg-opacity-50 p-2 rounded-full hover:bg-opacity-70 transition-all" data-visible="auth">
                    <i data-feather="edit-2" class="w-4 h-4"></i>
                </button>
                <input type="file" id="banner-input" accept="image/*" class="hidden">
            </div>
            
            <!-- Profile Info -->
            <div class="p-6 pt-0">
                <div class="flex flex-col sm:flex-row items-start sm:items-end justify-between gap-4 -mt-24 profile-header profile-block">
                    <div class="flex items-start sm:items-end">
                        <div class="relative">
                            <img id="profile-avatar" src="images/default-profil.jpg" data-placeholder="images/default-profil.jpg" alt="Profile" class="profile-avatar rounded-full border-4 border-dark-primary">
                            <button id="avatar-edit-btn" class="absolute bottom-0 right-0 bg-dark-accent p-1 rounded-full hover:bg-opacity-90 transition-all" data-visible="auth">
                                <i data-feather="camera" class="w-4 h-4"></i>
                            </button>
                            <input type="file" id="avatar-input" accept="image/*" class="hidden">
                        </div>
                        <div class="ml-4 mb-2">
                             <h1 id="profile-name" class="profile-name flex items-center gap-2">Utilisateur</h1>
                             <div class="flex items-baseline space-x-2 mt-1">
                                 <p class="profile-handle" id="profile-handle">@utilisateur</p>
                                 <button id="edit-handle-btn" class="edit-handle-btn" aria-label="Modifier le pseudo" title="Modifier le pseudo" data-visible="auth">
                                     <i data-feather="edit-2" class="w-4 h-4"></i>
                                 </button>
                             </div>
                         </div>
                    </div>
                    <div class="flex items-center gap-2 mb-2 w-full sm:w-auto flex-wrap sm:justify-end">
                        <button id="message-btn" class="px-4 py-2 rounded-full bg-dark-secondary bg-opacity-30 hover:bg-opacity-50 transition-all flex items-center gap-2" style="display:none;">
                            <i data-feather="mail" class="w-4 h-4"></i>
                            <span>Message</span>
                        </button>
                        <button id="follow-btn" class="px-6 py-2 rounded-full bg-dark-accent text-white font-semibold hover:bg-opacity-90 transition-all" style="display:none;">
                            S'abonner
                        </button>
                    </div>
                </div>
                <p id="thought-display" class="thought-display-style">Rien à partager pour le moment.</p>
                <!-- Stats -->
                <div class="flex justify-around py-3 border-y border-dark-secondary profile-separator">
                    <div class="text-center stat-item">
                        <div class="text-lg stat-number flex items-center justify-center">
                            <i data-feather="star" class="w-4 h-4"></i><span id="stat-points">0</span>
                        </div>
                        <div class="text-xs opacity-75 stat-label">Points</div>
                    </div>
                    <div class="text-center stat-item">
                        <div class="text-lg stat-number flex items-center justify-center">
                            <i data-feather="user" class="w-4 h-4"></i><span id="stat-followers">0</span>
                        </div>
                        <div class="text-xs opacity-75 stat-label">Abonnés</div>
                    </div>
                    <div class="text-center stat-item">
                        <div class="text-lg stat-number flex items-center justify-center">
                            <i data-feather="users" class="w-4 h-4"></i><span id="stat-following">0</span>
                        </div>
                        <div class="text-xs opacity-75 stat-label">Abonnements</div>
                    </div>
                </div>

                <p id="bio-display" class="mt-4 text-base font-bold text-left">Aucune bio pour le moment.</p>
                <!-- Bio Editor (hidden by default) -->
                <div id="bio-editor" class="mt-3" style="display:none;">
                    <label for="bio-input" class="sr-only">Bio</label>
                    <textarea id="bio-input" rows="4" maxlength="500" class="w-full p-3 rounded-lg bg-opacity-5 glass-card" placeholder="Écrivez votre bio ici..."></textarea>
                    <div class="flex items-center justify-between mt-2">
                        <div class="text-sm opacity-75"><span id="bio-count">0</span> / 500</div>
                        <div id="bio-update-actions" class="flex gap-2" style="display:flex;">
                            <button id="bio-cancel" class="px-3 py-1 rounded-full bg-dark-secondary bg-opacity-30">Annuler</button>
                            <button id="bio-save" class="px-3 py-1 rounded-full bg-dark-accent text-white">Enregistrer</button>
                        </div>
                    </div>
                </div>

                <!-- Thought Editor (hidden by default) -->
                <div id="thought-editor" class="mt-3" style="display:none;">
                    <label for="thought-input" class="sr-only">Pensée du moment</label>
                    <textarea id="thought-input" rows="3" maxlength="300" class="w-full p-3 rounded-lg bg-opacity-5 glass-card" placeholder="Votre pensée du moment..."></textarea>
                    <div class="flex items-center justify-between mt-2">
                        <div class="text-sm opacity-75"><span id="thought-count">0</span> / 300</div>
                        <div id="thought-update-actions" class="flex gap-2" style="display:flex;">
                            <button id="thought-cancel" class="px-3 py-1 rounded-full bg-dark-secondary bg-opacity-30">Annuler</button>
                            <button id="thought-save" class="px-3 py-1 rounded-full bg-dark-accent text-white">Publier</button>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <!-- Actions profil -->
        <div class="flex justify-end gap-4 mb-6 flex-wrap">
            <button id="bio-button" class="glass-card rounded-full px-5 py-3 flex items-center gap-2 bg-dark-secondary bg-opacity-30 hover:bg-opacity-50 transition-all" data-visible="auth" style="display:none;">
                <i data-feather="user" class="w-5 h-5"></i>
                <span class="text-sm font-semibold">Bio</span>
            </button>
            <button id="thought-button" class="glass-card rounded-full px-5 py-3 flex items-center gap-2 bg-dark-secondary bg-opacity-30 hover:bg-opacity-50 transition-all" data-visible="auth" style="display:none;">
                <i data-feather="message-circle" class="w-5 h-5"></i>
                <span class="text-sm font-semibold">Pensée du moment</span>
            </button>
        </div>

        <!-- Profile Tabs -->
        <div class="glass-card rounded-2xl p-4 mb-6">
            <div class="flex space-x-4 overflow-x-auto tabs" role="tablist" aria-label="Profile tabs">
                <button class="px-4 py-2 rounded-full bg-dark-accent text-white whitespace-nowrap tab-btn" data-tab="posts" aria-pressed="true">Mes Posts</button>
                <button class="px-4 py-2 rounded-full bg-dark-secondary bg-opacity-30 whitespace-nowrap tab-btn" data-tab="liked" aria-pressed="false">Vidéos Likées</button>
                <button class="px-4 py-2 rounded-full bg-dark-secondary bg-opacity-30 whitespace-nowrap tab-btn" data-tab="podcasts" aria-pressed="false">Podcasts</button>
                <button class="px-4 py-2 rounded-full bg-dark-secondary bg-opacity-30 whitespace-nowrap tab-btn" data-tab="activity" aria-pressed="false">Activité</button>
            </div>
        </div>

        <!-- Actions profil -->
        <div class="flex justify-end gap-4 mb-6 flex-wrap">
            <button id="badges-button" class="glass-card rounded-full px-5 py-3 flex items-center gap-2 bg-dark-secondary bg-opacity-30 hover:bg-opacity-50 transition-all" data-visible="auth">
                <i data-feather="award" class="w-5 h-5"></i>
                <span class="text-sm font-semibold">Badges</span>
            </button>
            <button id="settings-button" class="glass-card rounded-full px-5 py-3 flex items-center gap-2 bg-dark-secondary bg-opacity-30 hover:bg-opacity-50 transition-all" data-visible="auth">
                <i data-feather="settings" class="w-5 h-5"></i>
                <span class="text-sm font-semibold">Paramètres</span>
            </button>
        </div>

        <!-- User Posts -->
        <div id="user-posts" class="space-y-6">
            <div class="glass-card rounded-2xl p-6 text-center">
                <p class="text-sm opacity-75">Aucun post pour le moment.</p>
            </div>
        </div>
    </div>

    <!-- Badges Modal -->
    <div id="badges-modal" class="fixed inset-0 bg-black bg-opacity-60 backdrop-filter backdrop-blur-sm flex items-center justify-center z-50" style="display: none;">
        <div class="glass-card rounded-2xl p-6 max-w-lg w-full m-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Mes Badges</h2>
                <button id="badges-modal-close" class="p-1 rounded-full hover:bg-dark-secondary">
                    <i data-feather="x" class="w-5 h-5"></i>
                </button>
            </div>
            <div id="badges-modal-content" class="grid grid-cols-3 sm:grid-cols-4 gap-4">
                <!-- Contenu des badges sera injecté ici dynamiquement -->
                 <div class="badge" role="button" tabindex="0" aria-label="Badge Novice - Le premier badge obtenu en rejoignant la plateforme - 0-499 points">
                    <div class="w-16 h-16 bg-gradient-to-br from-blue-400 to-blue-600 rounded-full flex items-center justify-center p-1">
                        <img src="badges/novice.svg" alt="Badge Novice" class="w-14 h-14 rounded-full">
                    </div>
                    <div class="badge-label text-center">Novice</div>
                </div>
                <div class="badge" role="button" tabindex="0" aria-label="Badge New - Premier contenu ou interaction - 500-999 points">
                    <div class="w-16 h-16 bg-gradient-to-br from-green-400 to-green-600 rounded-full flex items-center justify-center p-1">
                        <img src="badges/new.svg" alt="Badge New" class="w-14 h-14 rounded-full">
                    </div>
                    <div class="badge-label text-center">New</div>
                </div>
                 <div class="badge" role="button" tabindex="0" aria-label="Badge First - Première action marquante - 1 000-1 499 points">
                    <div class="w-16 h-16 bg-gradient-to-br from-yellow-400 to-yellow-600 rounded-full flex items-center justify-center p-1">
                        <img src="badges/first.svg" alt="Badge First" class="w-14 h-14 rounded-full">
                    </div>
                    <div class="badge-label text-center">First</div>
                </div>
            </div>
            <div class="mt-6 text-center">
                <a href="badge-demo.html" class="text-sm text-blue-400 hover:underline">Voir la galerie de tous les badges</a>
            </div>
        </div>
    </div>

    <script>
        // --- Chargement dynamique du profil ---
        async function loadUserProfile() {
            const url = new URL(window.location.href);
            const paramId = url.searchParams.get('id');
            const supabase = await window.getSupabase();
            const { data: { user } } = await supabase.auth.getUser();

            // Persist and reuse a viewed profile id to survive refresh/navigation without query params
            let storedViewId = null;
            try { storedViewId = sessionStorage.getItem('viewingProfileId'); } catch (e) {}

            // Priority: explicit URL id > current user id (if logged in) > stored viewing id
            let targetUserId = null;
            if (paramId) {
                targetUserId = paramId;
            } else if (user && user.id) {
                targetUserId = user.id;
            } else if (storedViewId) {
                targetUserId = storedViewId;
            }

            if (!targetUserId) {
                console.error('Aucun utilisateur à charger (ni via URL, ni connecté).');
                // Optionnel: rediriger vers la page de connexion
                // window.location.href = 'login.html';
                return;
            }

            const { data: profile, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', targetUserId)
                .single();

            if (error) {
                console.error('Erreur lors du chargement du profil:', error);
                return;
            }

            // Mise à jour de l'interface
            const nameEl = document.getElementById('profile-name');
            if (nameEl) {
                // reset text and remove previous inline badge icons if any
                nameEl.textContent = profile.full_name || 'Utilisateur';
                // Ajouter l'icône de badge s'il est disponible
                if (profile.badge) {
                    const img = document.createElement('img');
                    img.src = `badges/${profile.badge}.svg`;
                    img.alt = 'Badge';
                    img.className = 'w-5 h-5 inline-block ml-2 align-middle rounded-full';
                    nameEl.appendChild(img);
                }
            }
            const handleEl = document.getElementById('profile-handle');
            if (handleEl) {
                handleEl.textContent = `@${profile.username}` || '@utilisateur';
                // Ajouter l'icône de badge s'il est disponible
                if (profile.badge) {
                    const img = document.createElement('img');
                    img.src = `badges/${profile.badge}.svg`;
                    img.alt = 'Badge';
                    img.className = 'w-4 h-4 inline-block ml-2 align-middle rounded-full';
                    handleEl.appendChild(img);
                }
            }
            document.getElementById('profile-avatar').src = profile.avatar_url || 'images/default-profil.jpg';
            document.getElementById('profile-banner').style.backgroundImage = `url(${profile.banner_url || 'images/banner.jpg'})`;
            document.getElementById('stat-points').textContent = profile.points || 0;
            document.getElementById('stat-followers').textContent = profile.followers_count || 0;
            document.getElementById('stat-following').textContent = profile.following_count || 0;
            document.getElementById('bio-display').textContent = profile.bio || 'Aucune bio pour le moment.';
            document.getElementById('thought-display').textContent = profile.thought || 'Rien à partager pour le moment.';

            // Gérer la visibilité des boutons d'édition
            const isOwnProfile = user && user.id === targetUserId;
            document.querySelectorAll('[data-visible="auth"]').forEach(el => {
                el.style.display = isOwnProfile ? 'inline-flex' : 'none';
            });

            // Mémoriser l'ID du profil actuellement consulté pour robustesse au refresh
            try { sessionStorage.setItem('viewingProfileId', String(targetUserId)); } catch (e) {}

            // Bouton message: visible uniquement si on consulte un autre profil
            const messageBtn = document.getElementById('message-btn');
            if (messageBtn) {
                if (!isOwnProfile) {
                    messageBtn.style.display = '';
                    messageBtn.onclick = () => {
                        // La page messages.html gère déjà la création/recherche de conversation via le paramètre 'to'
                        window.location.href = `messages.html?to=${encodeURIComponent(targetUserId)}`;
                    };
                } else {
                    messageBtn.style.display = 'none';
                }
            }

            // Appliquer l'arrière-plan de l'utilisateur consulté
            if (profile.background) {
                const bgElement = document.getElementById('vanta-bg');
                if (bgElement) {
                    // Sauvegarder l'arrière-plan actuel de l'utilisateur connecté
                    if (isOwnProfile) {
                        try {
                            localStorage.removeItem('profileBgBackup');
                        } catch (e) {}
                    } else {
                        // Sauvegarder l'arrière-plan actuel avant de changer
                        const currentBg = localStorage.getItem('selectedBg');
                        if (currentBg) {
                            try {
                                localStorage.setItem('profileBgBackup', currentBg);
                            } catch (e) {}
                        }
                    }
                    // Appliquer l'arrière-plan du profil consulté
                    bgElement.style.backgroundImage = `url('${profile.background}')`;
                }
            }

            // Le badge est déjà géré par badge-injector.js, pas besoin de le toucher ici.
        }

        // Initialize AOS and Feather Icons + Theme wiring via global-theme.js
        document.addEventListener('DOMContentLoaded', () => {
            loadUserProfile(); // Charger le profil au démarrage

            if (window.AOS) {
                AOS.init({ duration: 800, easing: 'ease-in-out', once: true });
            }
            if (window.feather) {
                feather.replace();
            }

            // Restaurer l'arrière-plan de l'utilisateur lors de la navigation
            window.addEventListener('beforeunload', () => {
                const backupBg = localStorage.getItem('profileBgBackup');
                if (backupBg) {
                    const bgElement = document.getElementById('vanta-bg');
                    if (bgElement) {
                        bgElement.style.backgroundImage = `url('${backupBg}')`;
                    }
                    try {
                        localStorage.setItem('selectedBg', backupBg);
                        localStorage.removeItem('profileBgBackup');
                    } catch (e) {}
                }
            });

            // --- Gestion de la modale des badges ---
            const badgesButton = document.getElementById('badges-button');
            const badgesModal = document.getElementById('badges-modal');
            const badgesModalClose = document.getElementById('badges-modal-close');
            const badgesModalContent = document.getElementById('badges-modal-content');

            function loadAllBadges() {
                // La constante BADGES_THRESHOLDS a été supprimée, nous utilisons donc une liste fixe.
                const badgeNames = [
                    'novice', 'new', 'first', 'step', 'calme', 'vérifié', 'vision', 
                    'rare', 'collector', 'explorateur', 'star', 'or', 'platine', 'diamant', 
                    'Ambassadeur', 'echoes'
                ];

                if (badgeNames.length > 0 && badgesModalContent) {
                    badgesModalContent.innerHTML = ''; // Vider le contenu existant
                    badgeNames.forEach(badgeName => {
                        const badgeEl = document.createElement('div');
                        badgeEl.className = 'badge text-center';
                        badgeEl.innerHTML = `
                            <div class="w-16 h-16 rounded-full flex items-center justify-center p-1 mx-auto">
                                <img src="badges/${badgeName}.svg" alt="Badge ${badgeName}" class="w-14 h-14 rounded-full">
                            </div>
                            <div class="badge-label mt-2 capitalize">${badgeName.replace('_', ' ')}</div>
                        `;
                        badgesModalContent.appendChild(badgeEl);
                    });
                }
            }

            if (badgesButton && badgesModal) {
                badgesButton.addEventListener('click', () => {
                    loadAllBadges(); // Charger les badges à chaque ouverture
                    badgesModal.style.display = 'flex';
                    feather.replace(); // Pour afficher les icônes dans la modale
                });

                badgesModalClose.addEventListener('click', () => {
                    badgesModal.style.display = 'none';
                });

                // Fermer en cliquant en dehors
                badgesModal.addEventListener('click', (e) => {
                    if (e.target === badgesModal) {
                        badgesModal.style.display = 'none';
                    }
                });
            }

            // Le thème est appliqué globalement via global-theme.js; aucun bouton local nécessaire

            // Simple tab active state (visuel seulement)
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => {
                        b.setAttribute('aria-pressed', 'false');
                        b.classList.remove('bg-dark-accent', 'text-white');
                        b.classList.add('bg-dark-secondary');
                    });
                    btn.setAttribute('aria-pressed', 'true');
                    btn.classList.add('bg-dark-accent', 'text-white');
                    btn.classList.remove('bg-dark-secondary');
                });
            });

            // Edition du pseudo : prompt simple
            const editHandleBtn = document.getElementById('edit-handle-btn');
            if (editHandleBtn) {
                editHandleBtn.addEventListener('click', async () => {
                    const handleEl = document.getElementById('profile-handle');
                    if (!handleEl) return;
                    const current = handleEl.textContent.trim().replace(/^@/, '');
                    const newHandle = prompt('Nouveau pseudo (sans @)', current);
                    if (newHandle !== null && newHandle.trim() !== current) {
                        const sanitized = newHandle.trim().replace(/^@/, '');
                        if (sanitized.length === 0) return;
                        
                        // Sauvegarder dans la base de données
                        try {
                            const supabase = await window.getSupabase();
                            const { data: { user } } = await supabase.auth.getUser();
                            if (user) {
                                // Vérifier d'abord si le nom d'utilisateur est déjà pris
                                const { data: existingUser, error: checkError } = await supabase
                                    .from('profiles')
                                    .select('id')
                                    .eq('username', sanitized)
                                    .neq('id', user.id)
                                    .maybeSingle();
                                
                                if (checkError) {
                                    console.error('Erreur vérification username:', checkError);
                                    alert('Erreur lors de la vérification du pseudo: ' + checkError.message);
                                    return;
                                }
                                
                                if (existingUser) {
                                    alert('Ce pseudo est déjà utilisé par un autre utilisateur. Veuillez en choisir un autre.');
                                    return;
                                }
                                
                                // Mettre à jour le profil avec le nouveau nom d'utilisateur
                                const { data, error } = await supabase
                                    .from('profiles')
                                    .update({ 
                                        username: sanitized,
                                        full_name: sanitized, // Mettre à jour également le nom complet
                                        updated_at: new Date().toISOString() 
                                    })
                                    .eq('id', user.id);
                                
                                if (error) {
                                    console.error('Erreur sauvegarde username:', error);
                                    alert('Erreur lors de la sauvegarde du pseudo: ' + error.message);
                                    return;
                                }
                                
                                // Mise à jour de l'interface uniquement après succès
                                handleEl.textContent = '@' + sanitized;
                                editHandleBtn.setAttribute('aria-label', 'Modifier le pseudo: ' + '@' + sanitized);
                                
                                // Mise à jour du nom dans l'en-tête du profil
                                const nameEl = document.getElementById('profile-name');
                                if (nameEl) nameEl.textContent = sanitized;
                                
                                console.log('Username sauvegardé avec succès:', sanitized);
                                alert('Pseudo modifié avec succès !');
                                
                                // Recharger la page pour s'assurer que tous les éléments sont mis à jour
                                setTimeout(() => {
                                    window.location.reload();
                                }, 1500);
                            }
                        } catch (e) {
                            console.error('Erreur sauvegarde username:', e);
                            alert('Erreur lors de la sauvegarde du pseudo: ' + (e.message || e));
                        }
                    }
                });
            }
        });
    </script>

    <script>
        // Settings panel simple drawer
        document.addEventListener('DOMContentLoaded', () => {
            const settingsBtn = document.getElementById('settings-button');
            if (!settingsBtn) return;

            // Create a basic settings drawer if not present
            let settingsDrawer = document.getElementById('settings-drawer');
            if (!settingsDrawer) {
                settingsDrawer = document.createElement('div');
                settingsDrawer.id = 'settings-drawer';
                settingsDrawer.style.display = 'none';
                // Center the drawer in the viewport
                settingsDrawer.className = 'fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 w-96 max-w-full glass-card rounded-xl p-4 z-50';
                // Ensure the settings drawer sits above high z-index elements like the floating nav
                settingsDrawer.style.zIndex = '10001';
                settingsDrawer.innerHTML = `
                    <div class="flex justify-between items-center mb-3">
                        <strong>Paramètres du profil</strong>
                        <button id="settings-close" class="px-2 py-1 rounded-full">✕</button>
                    </div>
                    <div class="space-y-3">
                        <div>
                            <div class="text-sm font-semibold mb-2">Thème</div>
                            <div class="flex gap-2 items-center">
                                <button id="theme-light" class="px-3 py-1 rounded-full bg-dark-secondary bg-opacity-20">Clair</button>
                                <button id="theme-dark" class="px-3 py-1 rounded-full bg-dark-secondary bg-opacity-20">Sombre</button>
                            </div>

                        </div>

                        <div class="border-t pt-2">
                            <div class="text-sm font-semibold mb-2">Arrière-plans</div>
                            <div id="settings-theme-bg-row" class="flex gap-2 overflow-x-auto pb-2">
                                <!-- Background thumbnails will be populated here -->
                            </div>
                        </div>

                        <div class="border-t pt-2">
                            <button id="open-change-handle" class="w-full px-3 py-2 rounded-full bg-dark-secondary bg-opacity-30">Modifier le pseudo</button>
                            <button id="open-change-avatar" class="w-full px-3 py-2 rounded-full bg-dark-secondary bg-opacity-30 mt-2">Changer l'avatar</button>
                            <button id="open-bio-editor" class="w-full px-3 py-2 rounded-full bg-dark-secondary bg-opacity-30 mt-2" data-visible="auth">Modifier la bio</button>
                            <button id="open-thought-editor" class="w-full px-3 py-2 rounded-full bg-dark-secondary bg-opacity-30 mt-2" data-visible="auth">Pensée du moment</button>
                            <button id="settings-signout" data-auth="signout" class="w-full px-3 py-2 rounded-full bg-dark-secondary bg-opacity-30 mt-2">Se déconnecter</button>
                            <button id="delete-account" class="w-full px-3 py-2 rounded-full bg-red-600 text-white mt-2">Supprimer le compte</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(settingsDrawer);
            }

            const closeBtn = settingsDrawer.querySelector('#settings-close');
            settingsBtn.addEventListener('click', () => {
                const willOpen = settingsDrawer.style.display === 'none';
                settingsDrawer.style.display = willOpen ? '' : 'none';
                if (window.feather) feather.replace();

                // When opening the settings drawer, ensure the theme backgrounds row is populated
                if (willOpen) {
                    // Build the thumbnail row at open time (select row locally to avoid ordering/hoisting issues)
                    const applyPopulate = () => {
                        try {
                            const themeBgRowLocal = settingsDrawer.querySelector('#settings-theme-bg-row');
                            if (!themeBgRowLocal) return;
                            themeBgRowLocal.innerHTML = '';

                            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
                            const list = (window.getBackgroundsByTheme && window.getBackgroundsByTheme(currentTheme)) || [];

                            list.forEach((url, idx) => {
                                const btn = document.createElement('button');
                                btn.className = 'min-w-[80px] h-16 rounded-md bg-cover bg-center border-2 border-transparent flex-shrink-0';
                                btn.style.backgroundImage = `url('${url}')`;
                                btn.title = url;
                                btn.setAttribute('aria-label', `${currentTheme} background ${idx+1}`);
                                btn.addEventListener('click', () => {
                                    if (window.setBackgroundImage) window.setBackgroundImage(url);
                                    // mark selection (visual)
                                    Array.from(themeBgRowLocal.children).forEach(c => c.classList.remove('ring-2','ring-offset-1','ring-blue-400'));
                                    btn.classList.add('ring-2','ring-offset-1','ring-blue-400');
                                });
                                themeBgRowLocal.appendChild(btn);
                            });

                            // mark current selection based on localStorage
                            const sel = localStorage.getItem('selectedBg');
                            if (sel) {
                                Array.from(themeBgRowLocal.children).forEach(child => {
                                    try { if ((child.title || '').toString() === sel) child.classList.add('ring-2','ring-offset-1','ring-blue-400'); } catch(e){}
                                });
                            }
                        } catch (e) { console.warn('populateThemeRow failed on open', e); }
                    };

                    // If background API isn't ready yet, wait for it
                    if (!window.getBackgroundsByTheme) {
                        const onReady = () => { applyPopulate(); document.removeEventListener('backgroundsReady', onReady); };
                        document.addEventListener('backgroundsReady', onReady);
                        // also try a short timeout fallback
                        setTimeout(applyPopulate, 300);
                    } else {
                        applyPopulate();
                    }
                }
            });
            if (closeBtn) closeBtn.addEventListener('click', () => settingsDrawer.style.display = 'none');

            // Wire some actions to existing elements if available
            const openChangeHandle = settingsDrawer.querySelector('#open-change-handle');
            if (openChangeHandle) openChangeHandle.addEventListener('click', () => {
                document.getElementById('edit-handle-btn')?.click();
            });

            const openChangeAvatar = settingsDrawer.querySelector('#open-change-avatar');
            if (openChangeAvatar) openChangeAvatar.addEventListener('click', () => {
                document.getElementById('avatar-edit-btn')?.click();
            });

            const openBioEditor = settingsDrawer.querySelector('#open-bio-editor');
            if (openBioEditor) openBioEditor.addEventListener('click', () => {
                const btn = document.getElementById('bio-button');
                if (btn) { btn.click(); return; }
                const editor = document.getElementById('bio-editor');
                if (editor) editor.style.display = '';
            });

            const openThoughtEditor = settingsDrawer.querySelector('#open-thought-editor');
            if (openThoughtEditor) openThoughtEditor.addEventListener('click', () => {
                const btn = document.getElementById('thought-button');
                if (btn) { btn.click(); return; }
                const editor = document.getElementById('thought-editor');
                if (editor) editor.style.display = '';
            });

            // Delete account button is directly wired by the global handler targeting #delete-account later in this file

            // Sign out button in settings
            const signOutBtn = settingsDrawer.querySelector('#settings-signout');
            if (signOutBtn) {
                signOutBtn.addEventListener('click', async () => {
                    try {
                        if (!window.getSupabase) return;
                        const supabase = await window.getSupabase();
                        await supabase.auth.signOut();
                    } catch (e) {
                        console.warn('Sign out failed:', e);
                    } finally {
                        // Redirect to login page
                        try { window.location.href = 'login.html'; } catch (e) {}
                    }
                });
            }

            // Theme controls
            const themeLight = settingsDrawer.querySelector('#theme-light');
            const themeDark = settingsDrawer.querySelector('#theme-dark');
            const themeBgRow = settingsDrawer.querySelector('#settings-theme-bg-row');
            const populateThemeRow = (theme) => {
                if (!themeBgRow) return;
                themeBgRow.innerHTML = '';
                const list = (window.getBackgroundsByTheme && window.getBackgroundsByTheme(theme)) || [];

                // remember the currently selected background to allow hover-preview revert
                const saved = (() => { try { return localStorage.getItem('selectedBg'); } catch (e) { return null; } })();

                list.forEach((url, idx) => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'min-w-[80px] h-16 rounded-md bg-cover bg-center border-2 border-transparent flex-shrink-0 overflow-hidden relative';
                    // background-image (kept for visual) + add an <img> fallback so thumbnails remain visible when CSS background not shown
                    btn.style.backgroundImage = `url('${url}')`;
                    const img = document.createElement('img');
                    img.src = url;
                    img.alt = `miniature ${idx+1}`;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.display = 'block';
                    img.style.pointerEvents = 'none';
                    btn.appendChild(img);
                    btn.title = url;
                    btn.setAttribute('aria-label', `${theme} background ${idx+1}`);
                    btn.setAttribute('role', 'button');
                    btn.setAttribute('aria-pressed', 'false');

                    // Click: set background and persist selection
                    const select = async () => {
                        try { if (window.setBackgroundImage) window.setBackgroundImage(url); else {
                            const target = document.getElementById('vanta-bg') || document.body; try{ target.style.backgroundImage = `url('${url}')`; }catch(e){}
                        } } catch(e){}
                        try { localStorage.setItem('selectedBg', url); } catch(e){}

                        // Save to database if user is logged in
                        try {
                            if (window.getSupabase) {
                                const supabase = await window.getSupabase();
                                const { data: { user } } = await supabase.auth.getUser();
                                if (user) {
                                    await supabase
                                        .from('profiles')
                                        .update({ background: url, updated_at: new Date().toISOString() })
                                        .eq('id', user.id);
                                }
                            }
                        } catch (e) {
                            console.warn('Failed to save background to database:', e);
                        }

                        // visual marker and aria
                        Array.from(themeBgRow.children).forEach(c => {
                            c.classList.remove('ring-2','ring-offset-1','ring-blue-400');
                            try { c.setAttribute('aria-pressed','false'); } catch(e){}
                        });
                        btn.classList.add('ring-2','ring-offset-1','ring-blue-400');
                        try { btn.setAttribute('aria-pressed','true'); } catch(e){}
                    };

                    btn.addEventListener('click', select);

                    // Hover preview: temporarily apply, revert on leave
                    btn.addEventListener('mouseenter', () => {
                        try { if (window.setBackgroundImage) window.setBackgroundImage(url); else {
                            const target = document.getElementById('vanta-bg') || document.body; try{ target.style.backgroundImage = `url('${url}')`; }catch(e){}
                        } } catch(e){}
                    });
                    btn.addEventListener('mouseleave', () => {
                        try {
                            const revert = (localStorage.getItem('selectedBg') || saved) || null;
                            if (revert) {
                                if (window.setBackgroundImage) window.setBackgroundImage(revert);
                                else { const target = document.getElementById('vanta-bg') || document.body; try{ target.style.backgroundImage = `url('${revert}')`; }catch(e){} }
                            }
                        } catch(e) {}
                    });

                    // Keyboard: Enter/Space to select; ArrowLeft/ArrowRight to move focus
                    btn.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter' || ev.key === ' ') {
                            ev.preventDefault();
                            select();
                            return;
                        }
                        if (ev.key === 'ArrowRight' || ev.key === 'Right') {
                            ev.preventDefault();
                            const next = btn.nextElementSibling;
                            if (next) next.focus();
                            return;
                        }
                        if (ev.key === 'ArrowLeft' || ev.key === 'Left') {
                            ev.preventDefault();
                            const prev = btn.previousElementSibling;
                            if (prev) prev.focus();
                            return;
                        }
                    });

                    themeBgRow.appendChild(btn);
                });

                // After adding thumbnails, position the rail to the far right so users can scroll from right -> left
                try {
                    setTimeout(() => {
                        try {
                            // scrollWidth ensures we move to the end even with variable content width
                            themeBgRow.scrollTo({ left: themeBgRow.scrollWidth, behavior: 'instant' });
                        } catch (e) {
                            try { themeBgRow.scrollLeft = themeBgRow.scrollWidth; } catch (e) {}
                        }
                    }, 60);
                } catch (e) {}

                // mark current selection if any
                try {
                    const sel = localStorage.getItem('selectedBg');
                    if (sel) {
                        Array.from(themeBgRow.children).forEach(child => {
                            try { if ((child.title || '') === sel) child.classList.add('ring-2','ring-offset-1','ring-blue-400'); child.setAttribute('aria-pressed','true'); } catch(e){}
                        });
                    }
                } catch(e) {}
            };

            if (themeLight) themeLight.addEventListener('click', () => { window.setTheme && window.setTheme('light'); populateThemeRow('light'); });
            if (themeDark) themeDark.addEventListener('click', () => { window.setTheme && window.setTheme('dark'); populateThemeRow('dark'); });

            // Populate initially based on current theme if backgrounds API already available
            try {
                const tryPopulate = () => {
                    populateThemeRow(document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                    // mark selection if any
                    const sel = localStorage.getItem('selectedBg');
                    if (sel && themeBgRow) {
                        Array.from(themeBgRow.children).forEach(child => {
                            try { if ((child.title || '') === sel) child.classList.add('ring-2','ring-offset-1','ring-blue-400'); } catch(e){}
                        });
                    }
                };
                if (window.getBackgroundsByTheme || window.backgroundsReady) tryPopulate();
                else document.addEventListener('backgroundsReady', tryPopulate, { once: true });
            } catch(e) {}

            // Update when global theme changes (in other places)
            document.addEventListener('themeChanged', (ev) => {
                const t = ev && ev.detail && ev.detail.theme ? ev.detail.theme : (document.documentElement.classList.contains('dark') ? 'dark' : 'light');
                populateThemeRow(t === 'dark' ? 'dark' : 'light');
            });

            // (Arrière-plan removed from settings drawer)
        });
    </script>

    <script>
        // Profile data loader via Supabase + badges toggle
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                if (!window.getSupabase) return;
                const supabase = await window.getSupabase();
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;

                // Determine which profile to display: URL id > my id (if logged in) > session viewingProfileId
                const urlParams = new URLSearchParams(window.location.search);
                let viewingId = null;
                try { viewingId = sessionStorage.getItem('viewingProfileId'); } catch (e) {}
                const profileId = urlParams.has('id')
                    ? urlParams.get('id')
                    : (user && user.id
                        ? user.id
                        : (viewingId || null));
                const isOwnProfile = profileId === user.id;
                
                const { data: profile, error } = await supabase
                    .from('profiles')
                    .select('full_name, username, avatar_url, points, posts_count, followers_count, following_count, bio, thought')
                    .eq('id', profileId)
                    .single();
                if (error) throw error;
                if (!profile) return;
                
                const nameEl = document.getElementById('profile-name');
                const handleEl = document.getElementById('profile-handle');
                const avatarEl = document.getElementById('profile-avatar');
                const bioDisplayEl = document.getElementById('bio-display');
                const bioInputEl = document.getElementById('bio-input');
                const bioCountEl = document.getElementById('bio-count');
                const bioActionsEl = document.getElementById('bio-update-actions');
                const thoughtDisplayEl = document.getElementById('thought-display');
                const thoughtInputEl = document.getElementById('thought-input');
                const thoughtCountEl = document.getElementById('thought-count');
                const thoughtActionsEl = document.getElementById('thought-update-actions');
                if (nameEl && profile.username) nameEl.textContent = profile.username;
                if (handleEl && profile.username) handleEl.textContent = '@' + profile.username;
                if (avatarEl && profile.avatar_url) avatarEl.src = profile.avatar_url;
                const bioValue = profile.bio && profile.bio.length ? profile.bio : '';
                if (bioDisplayEl) bioDisplayEl.textContent = bioValue.length ? bioValue : 'Aucune bio pour le moment.';
                if (bioInputEl) bioInputEl.value = bioValue;
                if (bioCountEl) bioCountEl.textContent = `${bioValue.length} / 500`;
                const thoughtValue = profile.thought && profile.thought.length ? profile.thought : '';
                if (thoughtDisplayEl) thoughtDisplayEl.textContent = thoughtValue.length ? thoughtValue : 'Rien à partager pour le moment.';
                if (thoughtInputEl) thoughtInputEl.value = thoughtValue;
                if (thoughtCountEl) thoughtCountEl.textContent = `${thoughtValue.length} / 300`;
                if (bioActionsEl) bioActionsEl.style.display = isOwnProfile ? 'flex' : 'none';
                if (thoughtActionsEl) thoughtActionsEl.style.display = isOwnProfile ? 'flex' : 'none';
                document.body.dataset.ownProfile = isOwnProfile ? 'true' : 'false';
                const s = (id, v)=>{ const el=document.getElementById(id); if(el && (v||v===0)) el.textContent=String(v); };
                s('stat-points', profile.points);
                s('stat-posts', profile.posts_count);
                s('stat-followers', profile.followers_count);
                s('stat-following', profile.following_count);
                
                // Register user badge with badge-injector
                if (profile.username && window.echoesPoints && window.registerUserBadge) {
                    const badgePath = window.echoesPoints.getBadgePath(profile.points || 0);
                    window.registerUserBadge(profile.username, badgePath);
                }
                
                // Vérifier si le profil est complet pour donner des points bonus
                if (window.echoesPoints && isOwnProfile) {
                    window.echoesPoints.checkProfileCompletion();
                }
                
                // Load banner image if exists
                const bannerEl = document.getElementById('profile-banner');
                if (bannerEl && profile.banner_url) {
                    bannerEl.style.backgroundImage = `url('${profile.banner_url}')`;
                    bannerEl.style.backgroundSize = 'cover';
                    bannerEl.style.backgroundPosition = 'center';
                }
                
                // Hide edit elements if viewing someone else's profile
                if (!isOwnProfile) {
                    document.querySelectorAll('[data-visible="auth"]').forEach(el => el.style.display = 'none');
                    const editHandleBtn = document.getElementById('edit-handle-btn');
                    if (editHandleBtn) editHandleBtn.style.display = 'none';
                } else {
                    // Ensure buttons are visible for own profile
                    document.querySelectorAll('[data-visible="auth"]').forEach(el => {
                        el.style.display = 'inline-flex';
                    });
                }
                
                // Persist the current viewed profile id so refresh keeps correct user
                try { sessionStorage.setItem('viewingProfileId', String(profileId)); } catch (e) {}

                document.dispatchEvent(new Event('pointsChanged'));
                if (window.feather) feather.replace();
            } catch(e) { /* silent */ }
        });
    </script>

    <script>
        // Badges toggle + paramètres accordéon
        document.addEventListener('DOMContentLoaded', () => {
            const badgesToggle = document.getElementById('badges-toggle');
            const badgesPanel = document.getElementById('badges-panel');
            if (badgesToggle && badgesPanel) {
                badgesToggle.addEventListener('click', () => {
                    const show = badgesPanel.style.display === 'none';
                    badgesPanel.style.display = show ? '' : 'none';
                    badgesToggle.textContent = show ? 'Masquer' : 'Afficher';
                });
            }


        });
    </script>

    <script>
        // Bio save + pensée save + compte actions
        document.addEventListener('DOMContentLoaded', () => {
            const bioInput = document.getElementById('bio-input');
            const bioCount = document.getElementById('bio-count');
            const bioSave = document.getElementById('bio-save');
            const bioCancel = document.getElementById('bio-cancel');
            const bioDisplay = document.getElementById('bio-display');
            const bioEditor = document.getElementById('bio-editor');
            const bioButton = document.getElementById('bio-button');
            const thoughtInput = document.getElementById('thought-input');
            const thoughtCount = document.getElementById('thought-count');
            const thoughtSave = document.getElementById('thought-save');
            const thoughtCancel = document.getElementById('thought-cancel');
            const thoughtDisplay = document.getElementById('thought-display');
            const thoughtEditor = document.getElementById('thought-editor');
            const thoughtButton = document.getElementById('thought-button');
            const isOwnProfile = document.body.dataset.ownProfile === 'true';

            const openSection = (editorEl) => {
                if (!editorEl || !isOwnProfile) return;
                editorEl.style.display = '';
            };

            const closeSection = (editorEl) => {
                if (!editorEl) return;
                editorEl.style.display = 'none';
            };

            const handleButtonVisibility = () => {
                if (!isOwnProfile) return;
                if (bioButton) bioButton.style.display = '';
                if (thoughtButton) thoughtButton.style.display = '';
            };

            handleButtonVisibility();

            if (bioInput && bioCount && bioEditor) {
                bioCount.textContent = `${bioInput.value.length} / 500`;
                bioInput.addEventListener('input', () => {
                    bioCount.textContent = `${bioInput.value.length} / 500`;
                });
                closeSection(bioEditor);
            }

            if (bioButton) {
                bioButton.addEventListener('click', () => {
                    const isOpen = bioEditor && bioEditor.style.display !== 'none';
                    if (bioEditor) bioEditor.style.display = isOpen ? 'none' : '';
                });
            }

            if (bioCancel) {
                bioCancel.addEventListener('click', () => closeSection(bioEditor));
            }

            if (bioSave) {
                bioSave.addEventListener('click', async () => {
                    try {
                        const supabase = await window.getSupabase();
                        const { data: { user } } = await supabase.auth.getUser();
                        if (!user) { alert('Veuillez vous connecter.'); return; }
                        const value = (bioInput.value || '').slice(0, 500);
                        const { error } = await supabase
                            .from('profiles')
                            .update({ bio: value, updated_at: new Date().toISOString() })
                            .eq('id', user.id);
                        if (error) throw error;
                        if (bioDisplay) bioDisplay.textContent = value || 'Aucune bio pour le moment.';
                        closeSection(bioEditor);
                        alert('Bio mise à jour.');
                    } catch (e) { alert('Erreur lors de la mise à jour de la bio.'); }
                });
            }

            if (thoughtInput && thoughtCount && thoughtEditor) {
                thoughtCount.textContent = `${thoughtInput.value.length} / 300`;
                thoughtInput.addEventListener('input', () => {
                    thoughtCount.textContent = `${thoughtInput.value.length} / 300`;
                });
                closeSection(thoughtEditor);
            }

            if (thoughtButton) {
                thoughtButton.addEventListener('click', () => {
                    const isOpen = thoughtEditor && thoughtEditor.style.display !== 'none';
                    if (thoughtEditor) thoughtEditor.style.display = isOpen ? 'none' : '';
                });
            }

            if (thoughtCancel) {
                thoughtCancel.addEventListener('click', () => closeSection(thoughtEditor));
            }

            if (thoughtSave) {
                thoughtSave.addEventListener('click', async () => {
                    try {
                        const supabase = await window.getSupabase();
                        const { data: { user } } = await supabase.auth.getUser();
                        if (!user) { alert('Veuillez vous connecter.'); return; }
                        const value = (thoughtInput.value || '').slice(0, 300);
                        const { error } = await supabase
                            .from('profiles')
                            .update({ thought: value, updated_at: new Date().toISOString() })
                            .eq('id', user.id);
                        if (error) throw error;
                        if (thoughtDisplay) thoughtDisplay.textContent = value || 'Rien à partager pour le moment.';
                        closeSection(thoughtEditor);
                        alert('Pensée publiée.');
                    } catch (e) { alert('Erreur lors de la mise à jour de la pensée.'); }
                });
            }

            const deleteBtn = document.getElementById('delete-account');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', async () => {
                    const c1 = confirm('Êtes-vous sûr de vouloir supprimer définitivement votre compte ?');
                    if (!c1) return;
                    const c2 = confirm('Cette action est irréversible. Confirmez la suppression.');
                    if (!c2) return;
                    try {
                        const supabase = await window.getSupabase();
                        const { data: { user } } = await supabase.auth.getUser();
                        if (!user) { alert('Non connecté.'); return; }
                        // Supprime le profil (les posts peuvent être supprimés en cascade si FK configurée)
                        const { error } = await supabase.from('profiles').delete().eq('id', user.id);
                        if (error) throw error;
                        
                        // Tenter de supprimer le compte d'authentification (peut échouer selon les politiques Supabase)
                        try {
                            const { error: deleteError } = await supabase.auth.admin.deleteUser(user.id);
                            if (!deleteError) {
                                alert('Votre compte a été complètement supprimé.');
                                window.location.href = 'login.html';
                                return;
                            }
                        } catch (e) {
                            console.log('Impossible de supprimer le compte auth côté client:', e);
                        }
                        
                        // Si la suppression du compte auth échoue, déconnecter et informer
                        await supabase.auth.signOut();
                        alert('Votre profil et vos données ont été supprimés.\n\nNote: Le compte d\'authentification (email) reste actif mais sans données associées. Pour une suppression complète, contactez le support.');
                        window.location.href = 'login.html';
                    } catch (e) {
                        alert('Suppression impossible (vérifiez les règles RLS et la configuration).');
                    }
                });
            }
        });
    </script>

    <script>
        // Load Profile Data - Fonction globale réutilisable
        async function loadProfileData() {
            try {
                const avatarImg = document.getElementById('profile-avatar');
                const bannerDiv = document.getElementById('profile-banner');

                const setAvatar = (src) => {
                    if (!avatarImg) return;
                    if (src) {
                        avatarImg.src = src;
                    } else {
                        const fallback = avatarImg.dataset.placeholder || '';
                        avatarImg.src = fallback || '';
                    }
                };

                const setBanner = (src) => {
                    if (!bannerDiv) return;
                    if (src) {
                        bannerDiv.style.backgroundImage = `url('${src}')`;
                        bannerDiv.style.backgroundSize = 'cover';
                        bannerDiv.style.backgroundPosition = 'center';
                    } else {
                        const fallback = bannerDiv.dataset.placeholder || '';
                        if (fallback) {
                            bannerDiv.style.backgroundImage = `url('${fallback}')`;
                            bannerDiv.style.backgroundSize = 'cover';
                            bannerDiv.style.backgroundPosition = 'center';
                        }
                    }
                };

                const supabase = await window.getSupabase();
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;

                const { data: profile, error } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('id', user.id)
                    .maybeSingle();

                if (error) throw error;

                console.log('Profil chargé:', profile);

                if (!profile) {
                    console.log('Aucun profil trouvé');
                    return;
                }

                console.log('Avatar URL:', profile.avatar_url);
                console.log('Banner URL:', profile.banner_url);
                
                setAvatar(profile.avatar_url || null);
                setBanner(profile.banner_url || null);

                // Name and username
                if (profile.full_name) {
                    document.getElementById('profile-name').textContent = profile.full_name;
                }
                if (profile.username) {
                    document.getElementById('profile-handle').textContent = '@' + profile.username;
                }
                // Stats
                if (profile.points !== null) {
                    document.getElementById('stat-points').textContent = profile.points;
                }
                if (profile.followers_count !== null) {
                    document.getElementById('stat-followers').textContent = profile.followers_count;
                }
                if (profile.following_count !== null) {
                    document.getElementById('stat-following').textContent = profile.following_count;
                }
                // Bio
                if (profile.bio) {
                    document.getElementById('bio-display').textContent = profile.bio;
                    document.getElementById('bio-input').value = profile.bio;
                }
                // Thought
                if (profile.thought) {
                    document.getElementById('thought-display').textContent = profile.thought;
                }
            } catch (e) {
                console.error('Erreur chargement profil:', e);
            }
        }

        // Charger au démarrage
        document.addEventListener('DOMContentLoaded', loadProfileData);
        
        // Rendre accessible globalement
        window.loadProfileData = loadProfileData;
    </script>

    <script>
        // Avatar and Banner Upload System
        async function initializeUploads() {
            // Attendre que Supabase soit prêt
            if (!window.getSupabase) {
                setTimeout(initializeUploads, 100);
                return;
            }

            const avatarEditBtn = document.getElementById('avatar-edit-btn');
            const avatarInput = document.getElementById('avatar-input');
            const avatarImg = document.getElementById('profile-avatar');
            const bannerEditBtn = document.getElementById('banner-edit-btn');
            const bannerInput = document.getElementById('banner-input');
            const bannerDiv = document.getElementById('profile-banner');

            const getSupabaseAndUser = async () => {
                const supabase = await window.getSupabase();
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) throw new Error('Non connecté');
                return { supabase, user };
            };

            const extractStoragePath = (publicUrl) => {
                if (!publicUrl) return null;
                try {
                    const { pathname } = new URL(publicUrl);
                    const bucketPrefix = '/storage/v1/object/public/profiles/';
                    const index = pathname.indexOf(bucketPrefix);
                    if (index === -1) return null;
                    return decodeURIComponent(pathname.slice(index + bucketPrefix.length));
                } catch (err) {
                    console.warn('Impossible de parser l\'URL de stockage:', err);
                    return null;
                }
            };

            const deleteFromStorage = async (supabase, publicUrl) => {
                const objectPath = extractStoragePath(publicUrl);
                if (!objectPath) return;
                const { error } = await supabase.storage
                    .from('profiles')
                    .remove([objectPath]);
                if (error) {
                    console.warn('Suppression de l\'ancien fichier échouée:', error);
                }
            };

            const fetchCurrentField = async (supabase, user, field) => {
                const { data, error } = await supabase
                    .from('profiles')
                    .select(field)
                    .eq('id', user.id)
                    .maybeSingle();
                if (error) throw error;
                return data ? data[field] : null;
            };

            const uploadImage = async (supabase, user, file, folder) => {
                try {
                    const fileExt = file.name.split('.').pop();
                    const fileName = `${user.id}/${folder}/${Date.now()}.${fileExt}`;

                    const { error } = await supabase.storage
                        .from('profiles')
                        .upload(fileName, file, { upsert: true });

                    if (error) throw error;

                    const { data: publicData } = supabase.storage
                        .from('profiles')
                        .getPublicUrl(fileName);

                    if (!publicData || !publicData.publicUrl) {
                        throw new Error('URL publique introuvable après upload.');
                    }

                    return publicData.publicUrl;
                } catch (e) {
                    console.error('Upload error:', e);
                    throw e;
                }
            };

            const updateProfile = async (supabase, user, field, url) => {
                try {
                    const updates = {
                        [field]: url,
                        updated_at: new Date().toISOString()
                    };
                    const { error } = await supabase
                        .from('profiles')
                        .update(updates)
                        .eq('id', user.id);

                    if (error) throw error;
                } catch (e) {
                    console.error('Profile update error:', e);
                    throw e;
                }
            };

            // Avatar upload handler
            if (avatarEditBtn && avatarInput) {
                avatarEditBtn.addEventListener('click', () => avatarInput.click());
                
                avatarInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;

                    if (!file.type.startsWith('image/')) {
                        alert('Veuillez sélectionner une image.');
                        return;
                    }

                    if (file.size > 5 * 1024 * 1024) {
                        alert('L\'image ne doit pas dépasser 5MB.');
                        return;
                    }

                    try {
                        avatarEditBtn.disabled = true;
                        avatarEditBtn.innerHTML = '<i data-feather="loader" class="w-4 h-4 animate-spin"></i>';
                        if (window.feather) feather.replace();

                        const { supabase, user } = await getSupabaseAndUser();
                        const previousUrl = await fetchCurrentField(supabase, user, 'avatar_url');

                        const publicUrl = await uploadImage(supabase, user, file, 'avatars');
                        await updateProfile(supabase, user, 'avatar_url', publicUrl);

                        if (previousUrl && previousUrl !== publicUrl) {
                            await deleteFromStorage(supabase, previousUrl);
                        }
                        
                        if (typeof window.loadProfileData === 'function') {
                            await window.loadProfileData();
                        } else {
                            avatarImg.src = publicUrl;
                        }
                        alert('Photo de profil mise à jour !');
                    } catch (e) {
                        alert('Erreur lors de l\'upload: ' + (e.message || e));
                    } finally {
                        avatarEditBtn.disabled = false;
                        avatarEditBtn.innerHTML = '<i data-feather="camera" class="w-4 h-4"></i>';
                        if (window.feather) feather.replace();
                        avatarInput.value = '';
                    }
                });
            }

            // Banner upload handler
            if (bannerEditBtn && bannerInput) {
                bannerEditBtn.addEventListener('click', () => bannerInput.click());
                
                bannerInput.addEventListener('change', async (e) => {
                    const file = e.target.files?.[0];
                    if (!file) return;

                    if (!file.type.startsWith('image/')) {
                        alert('Veuillez sélectionner une image.');
                        return;
                    }

                    if (file.size > 5 * 1024 * 1024) {
                        alert('L\'image ne doit pas dépasser 5MB.');
                        return;
                    }

                    try {
                        bannerEditBtn.disabled = true;
                        bannerEditBtn.innerHTML = '<i data-feather="loader" class="w-4 h-4 animate-spin"></i>';
                        if (window.feather) feather.replace();

                        const { supabase, user } = await getSupabaseAndUser();
                        const previousUrl = await fetchCurrentField(supabase, user, 'banner_url');

                        console.log('Début upload banner...');
                        const publicUrl = await uploadImage(supabase, user, file, 'banners');
                        console.log('URL publique banner:', publicUrl);
                        
                        await updateProfile(supabase, user, 'banner_url', publicUrl);
                        console.log('Profil banner mis à jour');

                        if (previousUrl && previousUrl !== publicUrl) {
                            await deleteFromStorage(supabase, previousUrl);
                        }
                        
                        if (bannerDiv) {
                            bannerDiv.style.backgroundImage = `url('${publicUrl}')`;
                            bannerDiv.style.backgroundSize = 'cover';
                            bannerDiv.style.backgroundPosition = 'center';
                        }
                        
                        // Recharger le profil complet
                        if (typeof window.loadProfileData === 'function') {
                            await window.loadProfileData();
                        }
                    } catch (e) {
                        console.error('Erreur upload banner:', e);
                        alert('Erreur lors de l\'upload: ' + (e.message || e));
                    } finally {
                        bannerEditBtn.disabled = false;
                        bannerEditBtn.innerHTML = '<i data-feather="edit-2" class="w-4 h-4"></i>';
                        if (window.feather) feather.replace();
                        bannerInput.value = '';
                    }
                });
            }
        }

        // Initialiser les uploads
        initializeUploads();
    </script>

    <script>
        // Follow/Unfollow system
        document.addEventListener('DOMContentLoaded', async () => {
            const followBtn = document.getElementById('follow-btn');
            if (!followBtn) return;

            try {
                if (!window.getSupabase) return;
                const supabase = await window.getSupabase();
                const { data: { user } } = await supabase.auth.getUser();
                if (!user) return;

                // Get profile ID from URL (e.g., ?id=user_id) or use current user's ID
                const urlParams = new URLSearchParams(window.location.search);
                const profileId = urlParams.get('id') || user.id;

                // Don't show follow button on own profile
                if (profileId === user.id) {
                    followBtn.style.display = 'none';
                    return;
                }

                // Show the button
                followBtn.style.display = '';

                // Check if already following
                const checkFollowing = async () => {
                    const { data } = await supabase
                        .from('follows')
                        .select('id')
                        .eq('follower_id', user.id)
                        .eq('following_id', profileId)
                        .single();
                    return !!data;
                };

                const updateButton = async () => {
                    const isFollowing = await checkFollowing();
                    if (isFollowing) {
                        followBtn.textContent = 'Abonné';
                        followBtn.classList.remove('bg-dark-accent');
                        followBtn.classList.add('bg-dark-secondary', 'bg-opacity-50');
                    } else {
                        followBtn.textContent = 'S\'abonner';
                        followBtn.classList.add('bg-dark-accent');
                        followBtn.classList.remove('bg-dark-secondary', 'bg-opacity-50');
                    }
                };

                await updateButton();

                followBtn.addEventListener('click', async () => {
                    const isFollowing = await checkFollowing();
                    
                    if (isFollowing) {
                        // Unfollow
                        const { error } = await supabase
                            .from('follows')
                            .delete()
                            .eq('follower_id', user.id)
                            .eq('following_id', profileId);
                        
                        if (!error) {
                            // Update follower count
                            await supabase.rpc('decrement_followers', { user_id: profileId });
                            await supabase.rpc('decrement_following', { user_id: user.id });
                        }
                    } else {
                        // Follow
                        const { error } = await supabase
                            .from('follows')
                            .insert({ follower_id: user.id, following_id: profileId });
                        
                        if (!error) {
                            // Update follower count
                            await supabase.rpc('increment_followers', { user_id: profileId });
                            await supabase.rpc('increment_following', { user_id: user.id });
                        }
                    }

                    await updateButton();
                    // Refresh stats
                    window.location.reload();
                });
            } catch (e) { /* silent */ }
        });
    </script>

    <!-- Lightbox pour les images de posts -->
    <div id="image-lightbox" class="hidden fixed inset-0 z-50 items-center justify-center bg-black bg-opacity-75 p-4">
        <div class="relative max-w-4xl w-full">
            <button id="close-lightbox" class="absolute top-2 right-2 text-white z-50">✕</button>
            <img id="lightbox-image" src="" alt="" class="w-full h-auto rounded-lg shadow-lg" />
        </div>
    </div>

    <script>
        // Settings panel simple drawer
        document.addEventListener('DOMContentLoaded', () => {
            const settingsBtn = document.getElementById('settings-button');
            if (!settingsBtn) return;
        });

        // Make function globally available for testing
        window.updateProfileBadges = updateProfileBadges;
    </script>

    <script src="global-theme.js"></script>
    <script src="notifications.js"></script>
    <script src="user-badge-display.js"></script>
    <script src="interactions.js"></script>
    <script src="badge-system.js"></script>
    <script src="background-selector.js"></script>
    <script src="background-init.js"></script>
    <script src="posts.js"></script>
    <script>
    // Script section arrière-plans réduit (prévenir erreurs de syntaxe si fonctionnalités absentes)
    (function(){})();
    </script>
    <script>
      // Initialiser l'affichage des posts de l'utilisateur sur la page profil
      document.addEventListener('DOMContentLoaded', async () => {
        try { if (window.echoesPosts && window.echoesPosts.initProfilePostsUI) await window.echoesPosts.initProfilePostsUI(); } catch(e) {}
      });
    </script>
  </body>
  </html>